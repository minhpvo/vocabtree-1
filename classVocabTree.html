<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>vocabtree: VocabTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vocabtree
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classVocabTree.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">VocabTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="vocab__tree_8hpp_source.html">vocab_tree.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for VocabTree:</div>
<div class="dyncontent">
<div class="center"><img src="classVocabTree__inherit__graph.png" border="0" usemap="#VocabTree_inherit__map" alt="Inheritance graph"/></div>
<map name="VocabTree_inherit__map" id="VocabTree_inherit__map">
<area shape="rect" id="node2" href="classSearchBase.html" title="Abstract class from which all search structures and methods derive from." alt="" coords="5,5,99,32"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for VocabTree:</div>
<div class="dyncontent">
<div class="center"><img src="classVocabTree__coll__graph.png" border="0" usemap="#VocabTree_coll__map" alt="Collaboration graph"/></div>
<map name="VocabTree_coll__map" id="VocabTree_coll__map">
<area shape="rect" id="node2" href="classSearchBase.html" title="Abstract class from which all search structures and methods derive from." alt="" coords="5,5,99,32"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVocabTree_1_1MatchResults.html">MatchResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of match results base which also returns scores.  <a href="structVocabTree_1_1MatchResults.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVocabTree_1_1SearchParams.html">SearchParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of train params base which specifies Vocab Tree training parameters.  <a href="structVocabTree_1_1SearchParams.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVocabTree_1_1TrainParams.html">TrainParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of train params base which specifies vocab tree training parameters.  <a href="structVocabTree_1_1TrainParams.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVocabTree_1_1TreeNode.html">TreeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af3aec1ffd6c9ce7ad5b85f477d1a163d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#af3aec1ffd6c9ce7ad5b85f477d1a163d">VocabTree</a> ()</td></tr>
<tr class="separator:af3aec1ffd6c9ce7ad5b85f477d1a163d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9c57f3d8924489f1f627ac146b792c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#aaf9c57f3d8924489f1f627ac146b792c">train</a> (<a class="el" href="classDataset.html">Dataset</a> &amp;dataset, const std::shared_ptr&lt; const <a class="el" href="structTrainParamsBase.html">TrainParamsBase</a> &gt; &amp;params, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classImage.html">Image</a> &gt; &gt; &amp;examples)</td></tr>
<tr class="memdesc:aaf9c57f3d8924489f1f627ac146b792c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of training parameters, list of images, trains.  <a href="#aaf9c57f3d8924489f1f627ac146b792c">More...</a><br/></td></tr>
<tr class="separator:aaf9c57f3d8924489f1f627ac146b792c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8645f1901ce25a989dacfba7642d328"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#ad8645f1901ce25a989dacfba7642d328">load</a> (const std::string &amp;file_path)</td></tr>
<tr class="memdesc:ad8645f1901ce25a989dacfba7642d328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a trained search structure from the input filepath.  <a href="#ad8645f1901ce25a989dacfba7642d328">More...</a><br/></td></tr>
<tr class="separator:ad8645f1901ce25a989dacfba7642d328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fcc2c407d6ad58d6589996ff023f3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#ac0fcc2c407d6ad58d6589996ff023f3f">save</a> (const std::string &amp;file_path) const </td></tr>
<tr class="memdesc:ac0fcc2c407d6ad58d6589996ff023f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a trained search structure to the input filepath.  <a href="#ac0fcc2c407d6ad58d6589996ff023f3f">More...</a><br/></td></tr>
<tr class="separator:ac0fcc2c407d6ad58d6589996ff023f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2e1e4f74178cf901a55f5ab8464933"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structMatchResultsBase.html">MatchResultsBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#a5f2e1e4f74178cf901a55f5ab8464933">search</a> (<a class="el" href="classDataset.html">Dataset</a> &amp;dataset, const std::shared_ptr&lt; const <a class="el" href="structSearchParamsBase.html">SearchParamsBase</a> &gt; &amp;params, const std::shared_ptr&lt; const <a class="el" href="classImage.html">Image</a> &gt; &amp;example)</td></tr>
<tr class="memdesc:a5f2e1e4f74178cf901a55f5ab8464933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of search parameters, a query image, searches for matching images and returns the match.  <a href="#a5f2e1e4f74178cf901a55f5ab8464933">More...</a><br/></td></tr>
<tr class="separator:a5f2e1e4f74178cf901a55f5ab8464933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03781b2b2aabae3d2c1adc6b1cc27bb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#ad03781b2b2aabae3d2c1adc6b1cc27bb">tree_splits</a> () const </td></tr>
<tr class="memdesc:ad03781b2b2aabae3d2c1adc6b1cc27bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the split size of each node  <a href="#ad03781b2b2aabae3d2c1adc6b1cc27bb">More...</a><br/></td></tr>
<tr class="separator:ad03781b2b2aabae3d2c1adc6b1cc27bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fcdee663231eee8fe39491653c3ebb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#ab9fcdee663231eee8fe39491653c3ebb">tree_depth</a> () const </td></tr>
<tr class="memdesc:ab9fcdee663231eee8fe39491653c3ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the depth size of tree  <a href="#ab9fcdee663231eee8fe39491653c3ebb">More...</a><br/></td></tr>
<tr class="separator:ab9fcdee663231eee8fe39491653c3ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSearchBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSearchBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSearchBase.html">SearchBase</a></td></tr>
<tr class="memitem:a7aba064ebd8ce5f40aad2607c701f001 inherit pub_methods_classSearchBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearchBase.html#a7aba064ebd8ce5f40aad2607c701f001">SearchBase</a> ()</td></tr>
<tr class="separator:a7aba064ebd8ce5f40aad2607c701f001 inherit pub_methods_classSearchBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03054c23b9be014cdef02b892d799a0e inherit pub_methods_classSearchBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearchBase.html#a03054c23b9be014cdef02b892d799a0e">SearchBase</a> (const std::string &amp;file_path)</td></tr>
<tr class="separator:a03054c23b9be014cdef02b892d799a0e inherit pub_methods_classSearchBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa391cf064522f21c45f211da66882463 inherit pub_methods_classSearchBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearchBase.html#aa391cf064522f21c45f211da66882463">~SearchBase</a> ()</td></tr>
<tr class="separator:aa391cf064522f21c45f211da66882463 inherit pub_methods_classSearchBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8589889c76c103d15f75f0d55baf8fa0 inherit pub_methods_classSearchBase"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="structMatchResultsBase.html">MatchResultsBase</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSearchBase.html#a8589889c76c103d15f75f0d55baf8fa0">search</a> (<a class="el" href="classDataset.html">Dataset</a> &amp;dataset, const std::shared_ptr&lt; <a class="el" href="structSearchParamsBase.html">SearchParamsBase</a> &gt; &amp;params, const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classImage.html">Image</a> &gt; &gt; &amp;examples)</td></tr>
<tr class="memdesc:a8589889c76c103d15f75f0d55baf8fa0 inherit pub_methods_classSearchBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of search parameters, list of query images, searches for matching images and returns the result matches.  <a href="#a8589889c76c103d15f75f0d55baf8fa0">More...</a><br/></td></tr>
<tr class="separator:a8589889c76c103d15f75f0d55baf8fa0 inherit pub_methods_classSearchBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af0f6f4da15b2e8569198a5a490de35f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#af0f6f4da15b2e8569198a5a490de35f8">buildTreeRecursive</a> (uint32_t t, const cv::Mat &amp;descriptors, cv::TermCriteria &amp;tc, int attempts, int flags, int currLevel)</td></tr>
<tr class="memdesc:af0f6f4da15b2e8569198a5a490de35f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively builds a tree, starting with 0 and ending with currLevel = maxLevel-1.  <a href="#af0f6f4da15b2e8569198a5a490de35f8">More...</a><br/></td></tr>
<tr class="separator:af0f6f4da15b2e8569198a5a490de35f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3d3fedbda379a45bf95a63d217ce80"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#aca3d3fedbda379a45bf95a63d217ce80">generateVector</a> (const cv::Mat &amp;descriptors, bool shouldWeight, int64_t id=-1)</td></tr>
<tr class="memdesc:aca3d3fedbda379a45bf95a63d217ce80"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function, inserts a dummy possibleMatches  <a href="#aca3d3fedbda379a45bf95a63d217ce80">More...</a><br/></td></tr>
<tr class="separator:aca3d3fedbda379a45bf95a63d217ce80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2a16833429a3d19aef18f157f906fc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#acf2a16833429a3d19aef18f157f906fc">generateVector</a> (const cv::Mat &amp;descriptors, bool shouldWeight, std::unordered_set&lt; uint32_t &gt; &amp;possibleMatches, int64_t id=-1)</td></tr>
<tr class="memdesc:acf2a16833429a3d19aef18f157f906fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">To call with an id call without possibleMatches and it will go to the helper function Takes descriptors for an image and for each descriptor finds the path down the tree generating a vector (describing the path) Adds up all vectors (one from each descriptor) to return the vector of counts for each node If shouldWeight is true will weight each by the weight of the node, should be true for general query and false for construction If id is set then will insert that id into the invertedFile of each leaf visited, if negative or not set then won't do anything When id is not set will use insert images into possibleMatches, possibleMatches will not be used if id is set.  <a href="#acf2a16833429a3d19aef18f157f906fc">More...</a><br/></td></tr>
<tr class="separator:acf2a16833429a3d19aef18f157f906fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5841ebc34bd4986235e357a716681f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#aaf5841ebc34bd4986235e357a716681f">generateVectorHelper</a> (uint32_t nodeIndex, const cv::Mat &amp;descriptor, std::vector&lt; float &gt; &amp;counts, std::unordered_set&lt; uint32_t &gt; &amp;possibleMatches, int64_t id=-1)</td></tr>
<tr class="memdesc:aaf5841ebc34bd4986235e357a716681f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive function that recursively goes down the tree from t to find where the single descriptor belongs (stopping at leaf) On each node increments cound in the counts vector If id is set (&gt;=0) then adds the image with that id to the leaf Picks the child to traverse down based on the max dot product.  <a href="#aaf5841ebc34bd4986235e357a716681f">More...</a><br/></td></tr>
<tr class="separator:aaf5841ebc34bd4986235e357a716681f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6ab3b90e1675f17341675ca1419aad7d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#a6ab3b90e1675f17341675ca1419aad7d">split</a></td></tr>
<tr class="memdesc:a6ab3b90e1675f17341675ca1419aad7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the amount of splits used to generate tree  <a href="#a6ab3b90e1675f17341675ca1419aad7d">More...</a><br/></td></tr>
<tr class="separator:a6ab3b90e1675f17341675ca1419aad7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ade9822092326165d8710d8b1f7c639"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#a4ade9822092326165d8710d8b1f7c639">maxLevel</a></td></tr>
<tr class="memdesc:a4ade9822092326165d8710d8b1f7c639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the max level of the tree.  <a href="#a4ade9822092326165d8710d8b1f7c639">More...</a><br/></td></tr>
<tr class="separator:a4ade9822092326165d8710d8b1f7c639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4644191b6219ad132cc516216389eed9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9">numberOfNodes</a></td></tr>
<tr class="memdesc:a4644191b6219ad132cc516216389eed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of nodes the tree will have, saved in variable so don't have to recompute  <a href="#a4644191b6219ad132cc516216389eed9">More...</a><br/></td></tr>
<tr class="separator:a4644191b6219ad132cc516216389eed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183aed20b90dacfa47a454d6223bb094"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#a183aed20b90dacfa47a454d6223bb094">weights</a></td></tr>
<tr class="separator:a183aed20b90dacfa47a454d6223bb094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc8006fa8e445b834aa800f2e6f2069"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structVocabTree_1_1TreeNode.html">TreeNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a></td></tr>
<tr class="separator:a8dc8006fa8e445b834aa800f2e6f2069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e29a505f7c44a172c95bf8e9119e88"><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; std::unordered_map&lt; uint64_t, <br class="typebreak"/>
uint32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#a34e29a505f7c44a172c95bf8e9119e88">invertedFiles</a></td></tr>
<tr class="separator:a34e29a505f7c44a172c95bf8e9119e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af726c5bf8c1cae60b2d0753121322e6e"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; uint64_t, <br class="typebreak"/>
std::vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVocabTree.html#af726c5bf8c1cae60b2d0753121322e6e">databaseVectors</a></td></tr>
<tr class="memdesc:af726c5bf8c1cae60b2d0753121322e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the database vectors for all images in the database - d_i in the paper Indexes by the image id.  <a href="#af726c5bf8c1cae60b2d0753121322e6e">More...</a><br/></td></tr>
<tr class="separator:af726c5bf8c1cae60b2d0753121322e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="vocab__tree_8hpp_source.html#l00007">7</a> of file <a class="el" href="vocab__tree_8hpp_source.html">vocab_tree.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af3aec1ffd6c9ce7ad5b85f477d1a163d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VocabTree::VocabTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vocab__tree_8cxx_source.html#l00017">17</a> of file <a class="el" href="vocab__tree_8cxx_source.html">vocab_tree.cxx</a>.</p>
<div class="fragment"><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;                     : <a class="code" href="classSearchBase.html#a7aba064ebd8ce5f40aad2607c701f001">SearchBase</a>() {</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af0f6f4da15b2e8569198a5a490de35f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VocabTree::buildTreeRecursive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>descriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::TermCriteria &amp;&#160;</td>
          <td class="paramname"><em>tc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively builds a tree, starting with 0 and ending with currLevel = maxLevel-1. </p>

<p>Definition at line <a class="el" href="vocab__tree_8cxx_source.html#l00270">270</a> of file <a class="el" href="vocab__tree_8cxx_source.html">vocab_tree.cxx</a>.</p>

<p>References <a class="el" href="vocab__tree_8hpp_source.html#l00072">maxLevel</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00070">split</a>, and <a class="el" href="vocab__tree_8hpp_source.html#l00078">tree</a>.</p>

<p>Referenced by <a class="el" href="vocab__tree_8cxx_source.html#l00145">train()</a>.</p>
<div class="fragment"><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                                          {</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[t].invertedFileLength = descriptors.rows;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[t].level = currLevel;</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  <span class="comment">// handles the leaves</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  <span class="keywordflow">if</span> (currLevel == <a class="code" href="classVocabTree.html#a4ade9822092326165d8710d8b1f7c639" title="Stores the max level of the tree.">maxLevel</a> - 1) {</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[t].firstChildIndex = 0;</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  }</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  cv::Mat labels;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  cv::Mat centers;</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  std::vector&lt;cv::Mat&gt; groups(<a class="code" href="classVocabTree.html#a6ab3b90e1675f17341675ca1419aad7d" title="stores the amount of splits used to generate tree">split</a>);</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; <a class="code" href="classVocabTree.html#a6ab3b90e1675f17341675ca1419aad7d" title="stores the amount of splits used to generate tree">split</a>; i++)</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    groups[i] = cv::Mat();</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  <span class="comment">// printf(&quot;t: %d  rows: %d, counts: &quot;, t, descriptors.rows);</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;  <span class="keywordtype">bool</span> enoughToFill = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;  <span class="keywordflow">if</span> (descriptors.rows &gt;= split) {</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    cv::kmeans(descriptors, split, labels, tc, attempts, flags, centers);</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; labels.rows; i++) {</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;      <span class="keywordtype">int</span> index = labels.at&lt;<span class="keywordtype">int</span>&gt;(i);</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;      groups[index].push_back(descriptors.row(i));</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    }</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  }</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <span class="comment">// *** THIS SHOULDN&#39;T BE THE CASE, why is kmeans splitting poorly? ****</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    enoughToFill = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; descriptors.rows; i++)</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;      groups[i].push_back(descriptors.row(i));</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  }</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;  <span class="comment">// for (uint32_t i = 0; i &lt; split; i++)</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;  <span class="comment">//   printf(&quot;%d, &quot;, groups[i].rows);</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  <span class="comment">// printf(&quot;\n&quot;);</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  uint32_t totalChildren = pow(split, currLevel);</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;  </div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="preprocessor">#if ENABLE_MULTITHREADING &amp;&amp; ENABLE_OPENMP &amp;&amp; totalChildren&lt;maxThreads</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="preprocessor"></span>  uint32_t maxThreads = omp_get_num_threads();</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="preprocessor">#pragma omp parallel for schedule(dynamic)</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="preprocessor"></span>  <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; <a class="code" href="classVocabTree.html#a6ab3b90e1675f17341675ca1419aad7d" title="stores the amount of splits used to generate tree">split</a>; i++) {</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    uint32_t childLevelIndex = <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[t].levelIndex*split + i;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    uint32_t childIndex = (uint32_t)((pow(split, <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[t].level+1)-1) / (split - 1)) + childLevelIndex;</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    <span class="keywordflow">if</span> (enoughToFill)</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;      <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[childIndex].mean = centers.row(i);</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[childIndex].levelIndex = childLevelIndex;</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[childIndex].index = childIndex;</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="keywordflow">if</span> (i == 0)</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;      <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[t].firstChildIndex = childIndex;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    <a class="code" href="classVocabTree.html#af0f6f4da15b2e8569198a5a490de35f8" title="Recursively builds a tree, starting with 0 and ending with currLevel = maxLevel-1.">buildTreeRecursive</a>(childIndex, groups[i], tc, attempts, flags, currLevel + 1);</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;  }</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aca3d3fedbda379a45bf95a63d217ce80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; VocabTree::generateVector </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>descriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function, inserts a dummy possibleMatches </p>

<p>Definition at line <a class="el" href="vocab__tree_8cxx_source.html#l00331">331</a> of file <a class="el" href="vocab__tree_8cxx_source.html">vocab_tree.cxx</a>.</p>

<p>Referenced by <a class="el" href="vocab__tree_8cxx_source.html#l00415">search()</a>, and <a class="el" href="vocab__tree_8cxx_source.html#l00145">train()</a>.</p>
<div class="fragment"><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                                                                                                  {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;  std::unordered_set&lt;uint32_t&gt; dummy;</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classVocabTree.html#aca3d3fedbda379a45bf95a63d217ce80" title="helper function, inserts a dummy possibleMatches">generateVector</a>(descriptors, shouldWeight, dummy, <span class="keywordtype">id</span>);</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acf2a16833429a3d19aef18f157f906fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; VocabTree::generateVector </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>descriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>possibleMatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To call with an id call without possibleMatches and it will go to the helper function Takes descriptors for an image and for each descriptor finds the path down the tree generating a vector (describing the path) Adds up all vectors (one from each descriptor) to return the vector of counts for each node If shouldWeight is true will weight each by the weight of the node, should be true for general query and false for construction If id is set then will insert that id into the invertedFile of each leaf visited, if negative or not set then won't do anything When id is not set will use insert images into possibleMatches, possibleMatches will not be used if id is set. </p>

<p>Definition at line <a class="el" href="vocab__tree_8cxx_source.html#l00336">336</a> of file <a class="el" href="vocab__tree_8cxx_source.html">vocab_tree.cxx</a>.</p>

<p>References <a class="el" href="vocab__tree_8cxx_source.html#l00367">generateVectorHelper()</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00074">numberOfNodes</a>, and <a class="el" href="vocab__tree_8hpp_source.html#l00076">weights</a>.</p>
<div class="fragment"><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                                                            {</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  std::vector&lt;float&gt; vec(<a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>);</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;  <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; <a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>; i++)</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    vec[i] = 0;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; descriptors.rows; r++) {</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <a class="code" href="classVocabTree.html#aaf5841ebc34bd4986235e357a716681f" title="Recursive function that recursively goes down the tree from t to find where the single descriptor bel...">generateVectorHelper</a>(0, descriptors.row(r), vec, possibleMatches, id);</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;  }</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;  <span class="comment">// if shouldWeight is true then weight all values in the vector and normalize</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;  <span class="keywordflow">if</span> (shouldWeight) {</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    <span class="keywordtype">float</span> length = 0; <span class="comment">// for normalizing</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; <a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>; i++) {</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;      vec[i] *= <a class="code" href="classVocabTree.html#a183aed20b90dacfa47a454d6223bb094">weights</a>[i];</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;      length += vec[i] * vec[i];</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    }</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    length = sqrt(length);</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; <a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>; i++) {</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordflow">if</span>(length == 0)</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;      vec[i] = 0;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;      vec[i] /= length;</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    }</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  }</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;  <span class="keywordflow">return</span> vec;</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aaf5841ebc34bd4986235e357a716681f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VocabTree::generateVectorHelper </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>possibleMatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursive function that recursively goes down the tree from t to find where the single descriptor belongs (stopping at leaf) On each node increments cound in the counts vector If id is set (&gt;=0) then adds the image with that id to the leaf Picks the child to traverse down based on the max dot product. </p>

<p>Definition at line <a class="el" href="vocab__tree_8cxx_source.html#l00367">367</a> of file <a class="el" href="vocab__tree_8cxx_source.html">vocab_tree.cxx</a>.</p>

<p>References <a class="el" href="vocab__tree_8hpp_source.html#l00079">invertedFiles</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00070">split</a>, and <a class="el" href="vocab__tree_8hpp_source.html#l00078">tree</a>.</p>

<p>Referenced by <a class="el" href="vocab__tree_8cxx_source.html#l00336">generateVector()</a>.</p>
<div class="fragment"><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                                                            {</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  counts[nodeIndex]++;</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;  <span class="comment">// if leaf</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[nodeIndex].firstChildIndex &lt;= 0) {</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    std::unordered_map&lt;uint64_t, uint32_t&gt; &amp; invFile = <a class="code" href="classVocabTree.html#a34e29a505f7c44a172c95bf8e9119e88">invertedFiles</a>[<a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[nodeIndex].levelIndex];</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    <span class="comment">//printf(&quot;|%d|=%d, &quot;, tree[nodeIndex].levelIndex, invFile.size());</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    <span class="comment">// inserting image id into the inverted file</span></div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &gt;= 0) {</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;      <span class="comment">//printf(&quot;Leaf %d\n&quot;, nodeIndex);</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="preprocessor">#pragma omp critical</span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="preprocessor"></span>      {</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;      <span class="keywordflow">if</span> (invFile.find(<span class="keywordtype">id</span>) == invFile.end())</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        invFile[<span class="keywordtype">id</span>] = 1;</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        invFile[id]++;</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;      }</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    }</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    <span class="comment">// accumulating image id&#39;s into possibleMatches</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;      <span class="comment">// i don&#39;t like doing this serial, should find a better method</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;      <span class="comment">//typedef std::unordered_map&lt;uint64_t, uint32_t&gt;::iterator it_type;</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;      <span class="comment">//for (it_type iterator = invFile.begin(); iterator != invFile.end(); iterator++)</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;      possibleMatches.insert(tree[nodeIndex].levelIndex); <span class="comment">//iterator-&gt;first);</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    }</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;  }</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;  <span class="comment">// if inner node</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    uint32_t maxChild = tree[nodeIndex].firstChildIndex;</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    <span class="keywordtype">double</span> max = descriptor.dot(tree[maxChild].mean);</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    </div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    <span class="keywordflow">for</span> (uint32_t i = 1; i &lt; <a class="code" href="classVocabTree.html#a6ab3b90e1675f17341675ca1419aad7d" title="stores the amount of splits used to generate tree">split</a>; i++) {</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;      <span class="keywordflow">if</span> (tree[nodeIndex].invertedFileLength == 0)</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;      uint32_t childIndex = tree[nodeIndex].firstChildIndex + i;</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;      <span class="keywordtype">double</span> dot = descriptor.dot(tree[childIndex].mean);</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;      <span class="keywordflow">if</span> (dot&gt;max) {</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        max = dot;</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        maxChild = childIndex;</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;      }</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    }</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    <a class="code" href="classVocabTree.html#aaf5841ebc34bd4986235e357a716681f" title="Recursive function that recursively goes down the tree from t to find where the single descriptor bel...">generateVectorHelper</a>(maxChild, descriptor, counts, possibleMatches, <span class="keywordtype">id</span>);</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;  }</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad8645f1901ce25a989dacfba7642d328"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VocabTree::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a trained search structure from the input filepath. </p>

<p>Implements <a class="el" href="classSearchBase.html#a8af6d745f82a66b25fcf8cc012ff6e3e">SearchBase</a>.</p>

<p>Definition at line <a class="el" href="vocab__tree_8cxx_source.html#l00029">29</a> of file <a class="el" href="vocab__tree_8cxx_source.html">vocab_tree.cxx</a>.</p>

<p>References <a class="el" href="vocab__tree_8cxx_source.html#l00026">cvmat_header::cols</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00083">databaseVectors</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00024">cvmat_header::elem_size</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00025">cvmat_header::elem_type</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00079">invertedFiles</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00072">maxLevel</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00074">numberOfNodes</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00026">cvmat_header::rows</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00070">split</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00078">tree</a>, and <a class="el" href="vocab__tree_8hpp_source.html#l00076">weights</a>.</p>
<div class="fragment"><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;                                                {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  std::cout &lt;&lt; <span class="stringliteral">&quot;Reading vocab tree from &quot;</span> &lt;&lt; file_path &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  std::ifstream ifs(file_path, std::ios::binary);</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  ifs.read((<span class="keywordtype">char</span> *)&amp;<a class="code" href="classVocabTree.html#a6ab3b90e1675f17341675ca1419aad7d" title="stores the amount of splits used to generate tree">split</a>, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  ifs.read((<span class="keywordtype">char</span> *)&amp;<a class="code" href="classVocabTree.html#a4ade9822092326165d8710d8b1f7c639" title="Stores the max level of the tree.">maxLevel</a>, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  ifs.read((<span class="keywordtype">char</span> *)&amp;<a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <a class="code" href="classVocabTree.html#a183aed20b90dacfa47a454d6223bb094">weights</a>.resize(<a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  ifs.read((<span class="keywordtype">char</span> *)&amp;<a class="code" href="classVocabTree.html#a183aed20b90dacfa47a454d6223bb094">weights</a>[0], <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)*<a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="comment">// load image data</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  uint32_t imageCount;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  ifs.read((<span class="keywordtype">char</span> *)&amp;imageCount, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; imageCount; i++) {</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    uint64_t imageId;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    std::vector&lt;float&gt; vec(numberOfNodes);</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    ifs.read((<span class="keywordtype">char</span> *)&amp;imageId, <span class="keyword">sizeof</span>(uint64_t));</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    ifs.read((<span class="keywordtype">char</span> *)&amp;vec[0], <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)*numberOfNodes);</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <a class="code" href="classVocabTree.html#af726c5bf8c1cae60b2d0753121322e6e" title="Stores the database vectors for all images in the database - d_i in the paper Indexes by the image id...">databaseVectors</a>[imageId] = vec;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  }</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <span class="comment">// load inveted files</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  uint32_t invertedFileCount;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  ifs.read((<span class="keywordtype">char</span> *)&amp;invertedFileCount, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  <a class="code" href="classVocabTree.html#a34e29a505f7c44a172c95bf8e9119e88">invertedFiles</a>.resize(invertedFileCount);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; invertedFileCount; i++) {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    uint32_t size;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    ifs.read((<span class="keywordtype">char</span> *)&amp;size, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; size; j++) {</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;      uint64_t imageId;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;      uint32_t imageCount;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;      ifs.read((<span class="keywordtype">char</span> *)&amp;imageId, <span class="keyword">sizeof</span>(uint64_t));</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;      ifs.read((<span class="keywordtype">char</span> *)&amp;imageCount, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;      <a class="code" href="classVocabTree.html#a34e29a505f7c44a172c95bf8e9119e88">invertedFiles</a>[i][imageId] = imageCount;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    }</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  }</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="comment">// read in tree</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>.resize(numberOfNodes);</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; <a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>; i++) {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    ifs.read((<span class="keywordtype">char</span> *)&amp;<a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[i].firstChildIndex, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    ifs.read((<span class="keywordtype">char</span> *)&amp;<a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[i].index, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    ifs.read((<span class="keywordtype">char</span> *)&amp;<a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[i].invertedFileLength, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    ifs.read((<span class="keywordtype">char</span> *)&amp;<a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[i].level, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    ifs.read((<span class="keywordtype">char</span> *)&amp;<a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[i].levelIndex, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="comment">// read cv::mat, copied from filesystem.cxx</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <a class="code" href="structcvmat__header.html">cvmat_header</a> h;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    ifs.read((<span class="keywordtype">char</span> *)&amp;h, <span class="keyword">sizeof</span>(<a class="code" href="structcvmat__header.html">cvmat_header</a>));</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[i].mean.create(h.<a class="code" href="structcvmat__header.html#a09ca491336dde9ae4af2c1ea8aa6c266">rows</a>, h.<a class="code" href="structcvmat__header.html#a76c437502b110c5d026c71977ddd8ba2">cols</a>, h.<a class="code" href="structcvmat__header.html#a2e642b14dc5e5e0c7d7343b4c716c50d">elem_type</a>);</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">if</span> (h.<a class="code" href="structcvmat__header.html#a09ca491336dde9ae4af2c1ea8aa6c266">rows</a> == 0 || h.<a class="code" href="structcvmat__header.html#a76c437502b110c5d026c71977ddd8ba2">cols</a> == 0) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    ifs.read((<span class="keywordtype">char</span> *)<a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[i].mean.ptr(), h.<a class="code" href="structcvmat__header.html#a09ca491336dde9ae4af2c1ea8aa6c266">rows</a> * h.<a class="code" href="structcvmat__header.html#a76c437502b110c5d026c71977ddd8ba2">cols</a> * h.<a class="code" href="structcvmat__header.html#ab1156ab3006cb634c23e836c23e1f880">elem_size</a>);</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  }</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  std::cout &lt;&lt; <span class="stringliteral">&quot;Done reading vocab tree.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  </div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  <span class="keywordflow">return</span> (ifs.rdstate() &amp; std::ifstream::failbit) == 0;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac0fcc2c407d6ad58d6589996ff023f3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VocabTree::save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves a trained search structure to the input filepath. </p>

<p>Implements <a class="el" href="classSearchBase.html#ae221617eb05aa616397da75fa1760345">SearchBase</a>.</p>

<p>Definition at line <a class="el" href="vocab__tree_8cxx_source.html#l00090">90</a> of file <a class="el" href="vocab__tree_8cxx_source.html">vocab_tree.cxx</a>.</p>

<p>References <a class="el" href="vocab__tree_8cxx_source.html#l00026">cvmat_header::cols</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00083">databaseVectors</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00024">cvmat_header::elem_size</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00025">cvmat_header::elem_type</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00066">VocabTree::TreeNode::firstChildIndex</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00062">VocabTree::TreeNode::index</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00050">VocabTree::TreeNode::invertedFileLength</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00079">invertedFiles</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00053">VocabTree::TreeNode::level</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00059">VocabTree::TreeNode::levelIndex</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00072">maxLevel</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00063">VocabTree::TreeNode::mean</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00074">numberOfNodes</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00026">cvmat_header::rows</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00070">split</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00078">tree</a>, and <a class="el" href="vocab__tree_8hpp_source.html#l00076">weights</a>.</p>

<p>Referenced by <a class="el" href="bench__all_8cxx_source.html#l00091">train_tree()</a>.</p>
<div class="fragment"><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                                                      {</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  std::cout &lt;&lt; <span class="stringliteral">&quot;Writing vocab tree to &quot;</span> &lt;&lt; file_path &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  std::ofstream ofs(file_path, std::ios::binary | std::ios::trunc);</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  <span class="comment">//uint32_t num_clusters = inverted_index.size();</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;<a class="code" href="classVocabTree.html#a6ab3b90e1675f17341675ca1419aad7d" title="stores the amount of splits used to generate tree">split</a>, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;<a class="code" href="classVocabTree.html#a4ade9822092326165d8710d8b1f7c639" title="Stores the max level of the tree.">maxLevel</a>, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;<a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;<a class="code" href="classVocabTree.html#a183aed20b90dacfa47a454d6223bb094">weights</a>[0], <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)*<a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>); <span class="comment">// weights</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="comment">// write out databaseVectors</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  uint32_t imageCount = <a class="code" href="classVocabTree.html#af726c5bf8c1cae60b2d0753121322e6e" title="Stores the database vectors for all images in the database - d_i in the paper Indexes by the image id...">databaseVectors</a>.size();</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;imageCount, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; pair : <a class="code" href="classVocabTree.html#af726c5bf8c1cae60b2d0753121322e6e" title="Stores the database vectors for all images in the database - d_i in the paper Indexes by the image id...">databaseVectors</a>) {</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;pair.first, <span class="keyword">sizeof</span>(uint64_t));</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;(pair.second)[0], <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)*numberOfNodes); </div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  }</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  <span class="comment">// write out inverted files</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  uint32_t numInvertedFiles = <a class="code" href="classVocabTree.html#a34e29a505f7c44a172c95bf8e9119e88">invertedFiles</a>.size();</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;numInvertedFiles, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  <span class="keywordflow">for</span> (std::unordered_map&lt;uint64_t, uint32_t&gt; invFile : <a class="code" href="classVocabTree.html#a34e29a505f7c44a172c95bf8e9119e88">invertedFiles</a>) {</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    uint32_t size = invFile.size();</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;size, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    <span class="keywordflow">for</span> (std::pair&lt;uint64_t, uint32_t&gt; pair : invFile) {</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;      ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;pair.first, <span class="keyword">sizeof</span>(uint64_t));</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;      ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;pair.second, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    }</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  }</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  <span class="comment">// write out tree</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; <a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>; i++) {</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    TreeNode t = <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[i];</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;t.firstChildIndex, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;t.index, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;t.invertedFileLength, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;t.level, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    ofs.write((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;t.levelIndex, <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="comment">// write cv::mat, copied from filesystem.cxx</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <a class="code" href="structcvmat__header.html">cvmat_header</a> h;</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    h.<a class="code" href="structcvmat__header.html#ab1156ab3006cb634c23e836c23e1f880">elem_size</a> = t.mean.elemSize();</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    h.<a class="code" href="structcvmat__header.html#a2e642b14dc5e5e0c7d7343b4c716c50d">elem_type</a> = t.mean.type();</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    h.<a class="code" href="structcvmat__header.html#a09ca491336dde9ae4af2c1ea8aa6c266">rows</a> = t.mean.rows;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    h.<a class="code" href="structcvmat__header.html#a76c437502b110c5d026c71977ddd8ba2">cols</a> = t.mean.cols;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    ofs.write((<span class="keywordtype">char</span> *)&amp;h, <span class="keyword">sizeof</span>(<a class="code" href="structcvmat__header.html">cvmat_header</a>));</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    ofs.write((<span class="keywordtype">char</span> *)t.mean.ptr(), h.<a class="code" href="structcvmat__header.html#a09ca491336dde9ae4af2c1ea8aa6c266">rows</a> * h.<a class="code" href="structcvmat__header.html#a76c437502b110c5d026c71977ddd8ba2">cols</a> * h.<a class="code" href="structcvmat__header.html#ab1156ab3006cb634c23e836c23e1f880">elem_size</a>);</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  }</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  std::cout &lt;&lt; <span class="stringliteral">&quot;Done writing vocab tree.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="keywordflow">return</span> (ofs.rdstate() &amp; std::ofstream::failbit) == 0;;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5f2e1e4f74178cf901a55f5ab8464933"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structMatchResultsBase.html">MatchResultsBase</a> &gt; VocabTree::search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataset.html">Dataset</a> &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="structSearchParamsBase.html">SearchParamsBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classImage.html">Image</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>example</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a set of search parameters, a query image, searches for matching images and returns the match. </p>

<p>Implements <a class="el" href="classSearchBase.html#a8b42b92d30c0b4b7f5d43012f6232f8d">SearchBase</a>.</p>

<p>Definition at line <a class="el" href="vocab__tree_8cxx_source.html#l00415">415</a> of file <a class="el" href="vocab__tree_8cxx_source.html">vocab_tree.cxx</a>.</p>

<p>References <a class="el" href="vocab__tree_8hpp_source.html#l00083">databaseVectors</a>, <a class="el" href="filesystem_8cxx_source.html#l00012">filesystem::file_exists()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00331">generateVector()</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00079">invertedFiles</a>, <a class="el" href="filesystem_8cxx_source.html#l00042">filesystem::load_cvmat()</a>, <a class="el" href="dataset_8cxx_source.html#l00017">Dataset::location()</a>, and <a class="el" href="vocab__tree_8hpp_source.html#l00074">numberOfNodes</a>.</p>

<p>Referenced by <a class="el" href="vocab__tree__simple_8cxx_source.html#l00012">main()</a>.</p>
<div class="fragment"><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;                                              {</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;  std::cout &lt;&lt; <span class="stringliteral">&quot;Searching for matching images...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  <span class="keyword">const</span> std::shared_ptr&lt;const SearchParams&gt; &amp;ii_params = std::static_pointer_cast&lt;<span class="keyword">const</span> SearchParams&gt;(params);</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;  std::shared_ptr&lt;MatchResults&gt; match_result = std::make_shared&lt;MatchResults&gt;();</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;  <span class="comment">// get descriptors for example</span></div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;  <span class="keywordflow">if</span> (example == <span class="keyword">nullptr</span>) <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;  <span class="keyword">const</span> std::string &amp;descriptors_location = dataset.<a class="code" href="classDataset.html#a1be6c736cec176a950234ea610abf3e5" title="Returns the absolute path of the data directory.">location</a>(example-&gt;feature_path(<span class="stringliteral">&quot;descriptors&quot;</span>));</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="namespacefilesystem.html#a1d10e228c7c784ffc2e9c3c5bfc0dd11" title="Returns true if file exists at location, else returns false.">filesystem::file_exists</a>(descriptors_location)) <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;  cv::Mat descriptors, descriptorsf;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="namespacefilesystem.html#a4302c4377292b2c6dc2813cf5bb2b225" title="Loads a cv::Mat structure from the specified location.">filesystem::load_cvmat</a>(descriptors_location, descriptors)) <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;  std::unordered_set&lt;uint32_t&gt; possibleMatches;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;  descriptors.convertTo(descriptorsf, CV_32FC1);</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;  std::vector&lt;float&gt; vec = <a class="code" href="classVocabTree.html#aca3d3fedbda379a45bf95a63d217ce80" title="helper function, inserts a dummy possibleMatches">generateVector</a>(descriptorsf, <span class="keyword">true</span>, possibleMatches);</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;  <span class="keyword">typedef</span> std::pair&lt;uint64_t, float&gt; matchPair;</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  <span class="keyword">struct </span>myComparer {</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    <span class="keywordtype">bool</span> operator() (matchPair a, matchPair b) { <span class="keywordflow">return</span> a.second &lt; b.second; };</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;  } comparer;</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;  std::unordered_set&lt;uint64_t&gt; possibleImages;</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  <span class="keywordflow">for</span> (uint32_t elem : possibleMatches) {</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    std::unordered_map&lt;uint64_t, uint32_t&gt; &amp; invFile = <a class="code" href="classVocabTree.html#a34e29a505f7c44a172c95bf8e9119e88">invertedFiles</a>[elem];</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    <span class="keyword">typedef</span> std::unordered_map&lt;uint64_t, uint32_t&gt;::iterator it_type;</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    <span class="keywordflow">for</span> (it_type iterator = invFile.begin(); iterator != invFile.end(); iterator++)</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    <span class="keywordflow">if</span> (possibleImages.count(iterator-&gt;first) == 0)</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;      possibleImages.insert(iterator-&gt;first);</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;  }</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;  <span class="comment">//std::set&lt;matchPair, myComparer&gt; values;</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;  std::vector&lt;matchPair&gt; values;</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;  <span class="keywordflow">for</span> (uint64_t elem : possibleImages) {</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    <span class="comment">// compute L1 norm (based on paper eq 5)</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    <span class="comment">//float l1norm = 0;</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    <span class="keywordtype">float</span> score = 0;</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; <a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>; i++) {</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;      <span class="keywordtype">float</span> t = vec[i] - (<a class="code" href="classVocabTree.html#af726c5bf8c1cae60b2d0753121322e6e" title="Stores the database vectors for all images in the database - d_i in the paper Indexes by the image id...">databaseVectors</a>[elem])[i];</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;      score += t*t;</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;      <span class="comment">// std::cout &lt;&lt; vec[i] &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;      <span class="comment">//l1norm += abs(vec[i] * (databaseVectors[elem])[i]);</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    }</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    <span class="comment">//values[elem] = l1norm;</span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    <span class="comment">//values.insert(elem, l1norm));</span></div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    values.push_back(matchPair(elem, sqrt(score)));</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;  }</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  std::sort(values.begin(), values.end(), comparer);</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;  <span class="comment">// printf(&quot;%d matches\n&quot;, values.size());</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;  <span class="comment">// add all images in order or match</span></div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;  <span class="keywordflow">for</span> (matchPair m : values){</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    match_result-&gt;matches.push_back(m.first);</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    match_result-&gt;tfidf_scores.push_back(m.second);</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <span class="comment">// std::cout &lt;&lt; m.second &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  }</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;  <span class="comment">// add in matches, just do 2 for now</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;  <span class="comment">//possibleMatches.size() / 10.0</span></div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;  <span class="comment">/*for (int i = 0; i &lt; 1; i++) {</span></div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;<span class="comment">    std::set&lt;matchPair&gt;::iterator top = values.begin();</span></div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="comment">    match_result-&gt;matches.push_back(top-&gt;first);</span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="comment">    match_result-&gt;tfidf_scores.push_back(top-&gt;second);</span></div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="comment">  }*/</span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;  <span class="comment">//match_result-&gt;matches.push_back(0);</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;  <span class="keywordflow">return</span> (std::shared_ptr&lt;MatchResultsBase&gt;)match_result;</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aaf9c57f3d8924489f1f627ac146b792c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VocabTree::train </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataset.html">Dataset</a> &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="structTrainParamsBase.html">TrainParamsBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classImage.html">Image</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>examples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a set of training parameters, list of images, trains. </p>
<p>Returns true if successful, false if not successful. </p>

<p>Implements <a class="el" href="classSearchBase.html#a7f8a2ba4698c76ef8ca5b608e5de2ea4">SearchBase</a>.</p>

<p>Definition at line <a class="el" href="vocab__tree_8cxx_source.html#l00145">145</a> of file <a class="el" href="vocab__tree_8cxx_source.html">vocab_tree.cxx</a>.</p>

<p>References <a class="el" href="vocab__tree_8cxx_source.html#l00270">buildTreeRecursive()</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00083">databaseVectors</a>, <a class="el" href="filesystem_8cxx_source.html#l00012">filesystem::file_exists()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00331">generateVector()</a>, <a class="el" href="classDataset.html#a2b025f14638b6503644fe4bd98c7617a">Dataset::image()</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00079">invertedFiles</a>, <a class="el" href="filesystem_8cxx_source.html#l00042">filesystem::load_cvmat()</a>, <a class="el" href="dataset_8cxx_source.html#l00017">Dataset::location()</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00072">maxLevel</a>, <a class="el" href="vision_8cxx_source.html#l00256">vision::merge_descriptors()</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00074">numberOfNodes</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00070">split</a>, <a class="el" href="vocab__tree_8hpp_source.html#l00078">tree</a>, and <a class="el" href="vocab__tree_8hpp_source.html#l00076">weights</a>.</p>

<p>Referenced by <a class="el" href="vocab__tree__simple_8cxx_source.html#l00012">main()</a>, and <a class="el" href="bench__all_8cxx_source.html#l00091">train_tree()</a>.</p>
<div class="fragment"><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                                                            {</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  <span class="keyword">const</span> std::shared_ptr&lt;const TrainParams&gt; &amp;vt_params = std::static_pointer_cast&lt;<span class="keyword">const</span> TrainParams&gt;(params);</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  <a class="code" href="classVocabTree.html#a6ab3b90e1675f17341675ca1419aad7d" title="stores the amount of splits used to generate tree">split</a> = vt_params-&gt;split;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  <span class="comment">//uint32_t depth = vt_params-&gt;depth;</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <a class="code" href="classVocabTree.html#a4ade9822092326165d8710d8b1f7c639" title="Stores the max level of the tree.">maxLevel</a> = vt_params-&gt;depth;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  <a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a> = (uint32_t)(pow(split, <a class="code" href="classVocabTree.html#a4ade9822092326165d8710d8b1f7c639" title="Stores the max level of the tree.">maxLevel</a>) - 1) / (split - 1);</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  <a class="code" href="classVocabTree.html#a183aed20b90dacfa47a454d6223bb094">weights</a>.resize(<a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>);</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>.resize(<a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>);</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  <a class="code" href="classVocabTree.html#a34e29a505f7c44a172c95bf8e9119e88">invertedFiles</a>.resize((uint32_t)pow(split, <a class="code" href="classVocabTree.html#a4ade9822092326165d8710d8b1f7c639" title="Stores the max level of the tree.">maxLevel</a>-1));</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  <span class="comment">// took the following from bag_of_words</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  std::vector&lt;uint64_t&gt; all_ids(examples.size());</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;  <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; examples.size(); i++) {</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    all_ids[i] = examples[i]-&gt;id;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  }</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  std::random_shuffle(all_ids.begin(), all_ids.end());</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  std::vector&lt;cv::Mat&gt; all_descriptors;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  uint64_t num_features = 0;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; all_ids.size(); i++) {</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    std::shared_ptr&lt;Image&gt; image = std::static_pointer_cast&lt;<a class="code" href="classImage.html" title="Abstract class representing an image.">Image</a>&gt;(dataset.<a class="code" href="classDataset.html#a2b025f14638b6503644fe4bd98c7617a" title="Given a unique integer ID, returns an Image associated with that ID.">image</a>(all_ids[i]));</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <span class="keywordflow">if</span> (image == <span class="keyword">nullptr</span>) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keyword">const</span> std::string &amp;descriptors_location = dataset.<a class="code" href="classDataset.html#a1be6c736cec176a950234ea610abf3e5" title="Returns the absolute path of the data directory.">location</a>(image-&gt;feature_path(<span class="stringliteral">&quot;descriptors&quot;</span>));</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="namespacefilesystem.html#a1d10e228c7c784ffc2e9c3c5bfc0dd11" title="Returns true if file exists at location, else returns false.">filesystem::file_exists</a>(descriptors_location)) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    cv::Mat descriptors, descriptorsf;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacefilesystem.html#a4302c4377292b2c6dc2813cf5bb2b225" title="Loads a cv::Mat structure from the specified location.">filesystem::load_cvmat</a>(descriptors_location, descriptors)) {</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;      descriptors.convertTo(descriptorsf, CV_32FC1);</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;      num_features += descriptors.rows;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;      all_descriptors.push_back(descriptorsf);</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    }</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  }</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  <span class="keyword">const</span> cv::Mat merged_descriptor = <a class="code" href="namespacevision.html#a2f9f606d615708aad6f4f7002498b647" title="Merges the descriptors into a single matrix.">vision::merge_descriptors</a>(all_descriptors, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  cv::Mat labels;</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  uint32_t attempts = 1;</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  cv::TermCriteria tc(cv::TermCriteria::COUNT | cv::TermCriteria::EPS, 18, 0.000001);</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  <span class="comment">// end of stuff from bag of words</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[0].levelIndex = 0;</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  <a class="code" href="classVocabTree.html#a8dc8006fa8e445b834aa800f2e6f2069">tree</a>[0].index = 0;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  <a class="code" href="classVocabTree.html#af0f6f4da15b2e8569198a5a490de35f8" title="Recursively builds a tree, starting with 0 and ending with currLevel = maxLevel-1.">buildTreeRecursive</a>(0, merged_descriptor, tc, attempts, cv::KMEANS_PP_CENTERS, 0);</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  <a class="code" href="classVocabTree.html#af726c5bf8c1cae60b2d0753121322e6e" title="Stores the database vectors for all images in the database - d_i in the paper Indexes by the image id...">databaseVectors</a>.reserve(all_ids.size());</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  <span class="comment">// now generate data on the reference images - descriptors go down tree, add images to inverted lists at leaves, </span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  <span class="comment">//   and generate di vector for image</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  <span class="comment">// Also stores counts for how many images pass through each node to calculate weights</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  std::vector&lt;uint32_t&gt; counts(<a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>);</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>; i++)</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    counts[i] = 0;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="preprocessor">#if ENABLE_MULTITHREADING &amp;&amp; ENABLE_OPENMP</span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#pragma omp parallel for schedule(dynamic)</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="preprocessor"></span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; all_ids.size(); i++) {</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    std::shared_ptr&lt;Image&gt; image = std::static_pointer_cast&lt;<a class="code" href="classImage.html" title="Abstract class representing an image.">Image</a>&gt;(dataset.<a class="code" href="classDataset.html#a2b025f14638b6503644fe4bd98c7617a" title="Given a unique integer ID, returns an Image associated with that ID.">image</a>(all_ids[i]));</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    <span class="keywordflow">if</span> (image == <span class="keyword">nullptr</span>) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    <span class="keyword">const</span> std::string &amp;descriptors_location = dataset.<a class="code" href="classDataset.html#a1be6c736cec176a950234ea610abf3e5" title="Returns the absolute path of the data directory.">location</a>(image-&gt;feature_path(<span class="stringliteral">&quot;descriptors&quot;</span>));</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="namespacefilesystem.html#a1d10e228c7c784ffc2e9c3c5bfc0dd11" title="Returns true if file exists at location, else returns false.">filesystem::file_exists</a>(descriptors_location)) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    cv::Mat descriptors, descriptorsf;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacefilesystem.html#a4302c4377292b2c6dc2813cf5bb2b225" title="Loads a cv::Mat structure from the specified location.">filesystem::load_cvmat</a>(descriptors_location, descriptors)) {</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;      descriptors.convertTo(descriptorsf, CV_32FC1);</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;      std::vector&lt;float&gt; result = <a class="code" href="classVocabTree.html#aca3d3fedbda379a45bf95a63d217ce80" title="helper function, inserts a dummy possibleMatches">generateVector</a>(descriptorsf, <span class="keyword">false</span>, all_ids[i]);</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;      <span class="comment">// accumulate counts</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; <a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>; j++)</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <span class="keywordflow">if</span> (result[j] &gt; 0)</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;          counts[j]++;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;      <span class="comment">//databaseVectors.insert(std::make_pair&lt;uint64_t, std::vector&lt;float&gt;&gt;(all_ids[i], result));</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="preprocessor">#pragma omp critical</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="preprocessor"></span>      {</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        <a class="code" href="classVocabTree.html#af726c5bf8c1cae60b2d0753121322e6e" title="Stores the database vectors for all images in the database - d_i in the paper Indexes by the image id...">databaseVectors</a>[all_ids[i]] = result;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;      }</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    }</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  }</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  <span class="comment">// create weights according to equation 4: w_i = ln(N / N_i)</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>; i++) {</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="keywordflow">if</span> (counts[i] == 0)</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;      <a class="code" href="classVocabTree.html#a183aed20b90dacfa47a454d6223bb094">weights</a>[i] = 0;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;      <a class="code" href="classVocabTree.html#a183aed20b90dacfa47a454d6223bb094">weights</a>[i] = log(((<span class="keywordtype">float</span>)all_ids.size()) / ((<span class="keywordtype">float</span>)counts[i]));</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <span class="comment">// printf(&quot;Node %d, count %d, total %d, size %d, weight %f \n&quot;, i, counts[i], all_ids.size(), tree[i].invertedFileLength, weights[i]);</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;  }</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  <span class="comment">// now that we have the weights we iterate over all images and adjust the vector by weights, </span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  <span class="comment">//  then normalizes the vector</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  typedef std::unordered_map&lt;uint64_t, std::vector&lt;<span class="keywordtype">float</span>&gt;&gt;::iterator it_type;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;  for (it_type iterator = <a class="code" href="classVocabTree.html#af726c5bf8c1cae60b2d0753121322e6e" title="Stores the database vectors for all images in the database - d_i in the paper Indexes by the image id...">databaseVectors</a>.begin(); iterator != <a class="code" href="classVocabTree.html#af726c5bf8c1cae60b2d0753121322e6e" title="Stores the database vectors for all images in the database - d_i in the paper Indexes by the image id...">databaseVectors</a>.end(); iterator++) {</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    <span class="keywordtype">float</span> length = 0; <span class="comment">// hopefully shouldn&#39;t overflow from adding doubles</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>; i++) {</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;      (iterator-&gt;second)[i] *= <a class="code" href="classVocabTree.html#a183aed20b90dacfa47a454d6223bb094">weights</a>[i];</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;      length += (float)pow((iterator-&gt;second)[i], 2.0);</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    }</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="comment">// normalizing</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    length = sqrt(length);</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>; i++) </div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;      (iterator-&gt;second)[i] /= length;</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;  }</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; (uint32_t)pow(split, <a class="code" href="classVocabTree.html#a4ade9822092326165d8710d8b1f7c639" title="Stores the max level of the tree.">maxLevel</a> - 1); i++) {</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    <span class="comment">// printf(&quot;Size of inv file %d: %d\n&quot;, i, invertedFiles[i].size());</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  }</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  <span class="comment">// printf(&quot;\n\n&quot;);</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  uint32_t l = 0, inL = 0;</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; <a class="code" href="classVocabTree.html#a4644191b6219ad132cc516216389eed9" title="number of nodes the tree will have, saved in variable so don&#39;t have to recompute">numberOfNodes</a>; i++) {</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    <span class="comment">// printf(&quot;Node %d, num %d, weight %f || &quot;, i, tree[i].invertedFileLength, weights[i]);</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    inL++;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="keywordflow">if</span> (inL &gt;= (uint32_t)pow(split, l)) {</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;      l++;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;      inL = 0;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;      <span class="comment">// printf(&quot;\n&quot;);</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    }</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;  }</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab9fcdee663231eee8fe39491653c3ebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VocabTree::tree_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the depth size of tree </p>

<p>Definition at line <a class="el" href="vocab__tree_8cxx_source.html#l00495">495</a> of file <a class="el" href="vocab__tree_8cxx_source.html">vocab_tree.cxx</a>.</p>

<p>References <a class="el" href="vocab__tree_8hpp_source.html#l00072">maxLevel</a>.</p>
<div class="fragment"><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;                                     {</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classVocabTree.html#a4ade9822092326165d8710d8b1f7c639" title="Stores the max level of the tree.">maxLevel</a>;</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad03781b2b2aabae3d2c1adc6b1cc27bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VocabTree::tree_splits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the split size of each node </p>

<p>Definition at line <a class="el" href="vocab__tree_8cxx_source.html#l00491">491</a> of file <a class="el" href="vocab__tree_8cxx_source.html">vocab_tree.cxx</a>.</p>

<p>References <a class="el" href="vocab__tree_8hpp_source.html#l00070">split</a>.</p>
<div class="fragment"><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;                                      {</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classVocabTree.html#a6ab3b90e1675f17341675ca1419aad7d" title="stores the amount of splits used to generate tree">split</a>;</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="af726c5bf8c1cae60b2d0753121322e6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;uint64_t, std::vector&lt;float&gt; &gt; VocabTree::databaseVectors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the database vectors for all images in the database - d_i in the paper Indexes by the image id. </p>

<p>Definition at line <a class="el" href="vocab__tree_8hpp_source.html#l00083">83</a> of file <a class="el" href="vocab__tree_8hpp_source.html">vocab_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="vocab__tree_8cxx_source.html#l00029">load()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00090">save()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00415">search()</a>, and <a class="el" href="vocab__tree_8cxx_source.html#l00145">train()</a>.</p>

</div>
</div>
<a class="anchor" id="a34e29a505f7c44a172c95bf8e9119e88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unordered_map&lt;uint64_t, uint32_t&gt; &gt; VocabTree::invertedFiles</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vocab__tree_8hpp_source.html#l00079">79</a> of file <a class="el" href="vocab__tree_8hpp_source.html">vocab_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="vocab__tree_8cxx_source.html#l00367">generateVectorHelper()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00029">load()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00090">save()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00415">search()</a>, and <a class="el" href="vocab__tree_8cxx_source.html#l00145">train()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ade9822092326165d8710d8b1f7c639"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VocabTree::maxLevel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the max level of the tree. </p>

<p>Definition at line <a class="el" href="vocab__tree_8hpp_source.html#l00072">72</a> of file <a class="el" href="vocab__tree_8hpp_source.html">vocab_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="vocab__tree_8cxx_source.html#l00270">buildTreeRecursive()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00029">load()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00090">save()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00145">train()</a>, and <a class="el" href="vocab__tree_8cxx_source.html#l00495">tree_depth()</a>.</p>

</div>
</div>
<a class="anchor" id="a4644191b6219ad132cc516216389eed9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VocabTree::numberOfNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of nodes the tree will have, saved in variable so don't have to recompute </p>

<p>Definition at line <a class="el" href="vocab__tree_8hpp_source.html#l00074">74</a> of file <a class="el" href="vocab__tree_8hpp_source.html">vocab_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="vocab__tree_8cxx_source.html#l00336">generateVector()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00029">load()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00090">save()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00415">search()</a>, and <a class="el" href="vocab__tree_8cxx_source.html#l00145">train()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ab3b90e1675f17341675ca1419aad7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VocabTree::split</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stores the amount of splits used to generate tree </p>

<p>Definition at line <a class="el" href="vocab__tree_8hpp_source.html#l00070">70</a> of file <a class="el" href="vocab__tree_8hpp_source.html">vocab_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="vocab__tree_8cxx_source.html#l00270">buildTreeRecursive()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00367">generateVectorHelper()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00029">load()</a>, <a class="el" href="vocab__tree__simple_8cxx_source.html#l00012">main()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00090">save()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00145">train()</a>, <a class="el" href="bench__all_8cxx_source.html#l00091">train_tree()</a>, and <a class="el" href="vocab__tree_8cxx_source.html#l00491">tree_splits()</a>.</p>

</div>
</div>
<a class="anchor" id="a8dc8006fa8e445b834aa800f2e6f2069"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structVocabTree_1_1TreeNode.html">TreeNode</a>&gt; VocabTree::tree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vocab__tree_8hpp_source.html#l00078">78</a> of file <a class="el" href="vocab__tree_8hpp_source.html">vocab_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="vocab__tree_8cxx_source.html#l00270">buildTreeRecursive()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00367">generateVectorHelper()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00029">load()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00090">save()</a>, and <a class="el" href="vocab__tree_8cxx_source.html#l00145">train()</a>.</p>

</div>
</div>
<a class="anchor" id="a183aed20b90dacfa47a454d6223bb094"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; VocabTree::weights</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vocab__tree_8hpp_source.html#l00076">76</a> of file <a class="el" href="vocab__tree_8hpp_source.html">vocab_tree.hpp</a>.</p>

<p>Referenced by <a class="el" href="vocab__tree_8cxx_source.html#l00336">generateVector()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00029">load()</a>, <a class="el" href="vocab__tree_8cxx_source.html#l00090">save()</a>, and <a class="el" href="vocab__tree_8cxx_source.html#l00145">train()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/psastras/vocabtree/modules/search/vocab_tree/<a class="el" href="vocab__tree_8hpp_source.html">vocab_tree.hpp</a></li>
<li>/home/psastras/vocabtree/modules/search/vocab_tree/<a class="el" href="vocab__tree_8cxx_source.html">vocab_tree.cxx</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classVocabTree.html">VocabTree</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
